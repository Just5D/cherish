#Ascii Scene 
#Version 130 
#Generator OpenSceneGraph 3.4.0 

entity::UserScene {
  UniqueID 1 
  Name "UserScene" 
Children 2 {
entity::Bookmarks {
      UniqueID 2 
      Name "groupBookmarks" 
}
    osg::Group {
      UniqueID 3 
      Name "groupCanvases" 
Children 3 {
entity::Canvas {
          UniqueID 4 
          Name "Canvas0" 
Children 1 {
osg::MatrixTransform {
              UniqueID 5 
              Name "Transform" 
Children 1 {
osg::Switch {
                  UniqueID 6 
                  Name "Switch" 
Children 1 {
osg::Group {
                      UniqueID 7 
                      NodeMask 0x10 
Children 2 {
osg::Geode {
                          UniqueID 8 
                          StateSet TRUE {
osg::StateSet {
                              UniqueID 9 
                              AttributeList 1 {
osg::Program {
                                  UniqueID 10 
                                  Name "ProgramStroke" 
Shaders 3 {
osg::Shader {
                                      UniqueID 11 
                                      Type VERTEX 
ShaderSource 19 {
"#version 330" 
"" 
"uniform mat4 ModelViewProjectionMatrix;" 
"uniform mat4 CanvasMatrix;" 
"" 
"layout(location = 0) in vec4 Vertex;" 
"layout(location = 1) in vec4 Color;" 
"" 
"out VertexData{" 
"    vec4 mColor;" 
"    vec4 mVertex; // to calculate distance to camera eye" 
"} VertexOut;" 
"" 
"void main(void)" 
"{" 
"    VertexOut.mColor = Color;" 
"    VertexOut.mVertex = CanvasMatrix * Vertex;" 
"    gl_Position = ModelViewProjectionMatrix * Vertex;" 
"}" 
}
}
                                    osg::Shader {
                                      UniqueID 12 
                                      Type GEOMETRY 
ShaderSource 258 {
"#version 330" 
"" 
"uniform float Thickness;" 
"uniform vec2 Viewport;" 
"uniform float MiterLimit;" 
"uniform int Segments;" 
"uniform bool IsFogged;" 
"uniform float FogMin;" 
"uniform float FogMax;" 
"uniform vec4 CameraEye;" 
"" 
"const int SegmentsMax = 30; // max_vertices = (SegmentsMax+1)*4;" 
"const int SegmentsMin = 3; // min number of segments per curve" 
"" 
"layout(lines_adjacency) in;" 
"layout(triangle_strip, max_vertices = 124) out;" 
"" 
"in VertexData{" 
"    vec4 mColor;" 
"    vec4 mVertex;" 
"} VertexIn[4];" 
"" 
"out VertexData{" 
"    vec2 mTexCoord; // fix before usage" 
"    vec4 mColor;" 
"} VertexOut;" 
"" 
"vec2 toScreenSpace(vec4 vertex)" 
"{" 
"    return vec2( vertex.xy / vertex.w ) * Viewport;" 
"}" 
"" 
"float toZValue(vec4 vertex)" 
"{" 
"    return vertex.z / vertex.w;" 
"}" 
"" 
"vec2 toBezier(float delta, int i, vec2 b0, vec2 b1, vec2 b2, vec2 b3)" 
"{" 
"    float t = delta * float(i);" 
"    float t2 = t * t;" 
"    float one_minus_t = 1.0 - t;" 
"    float one_minus_t2 = one_minus_t * one_minus_t;" 
"    return (b0 * one_minus_t2 * one_minus_t + b1 * 3.0 * t * one_minus_t2 + b2 * 3.0 * t2 * one_minus_t + b3 * t2 * t);" 
"}" 
"" 
"vec4 toBezier3D(float delta, int i, vec4 B0, vec4 B1, vec4 B2, vec4 B3)" 
"{" 
"    float t = delta * float(i);" 
"    float t2 = t * t;" 
"    float one_minus_t = 1.0 - t;" 
"    float one_minus_t2 = one_minus_t * one_minus_t;" 
"    return (B0 * one_minus_t2 * one_minus_t + B1 * 3.0 * t * one_minus_t2 + B2 * 3.0 * t2 * one_minus_t + B3 * t2 * t);" 
"}" 
"" 
"float getFogFactor(float d)" 
"{" 
"    if (d>=FogMax) return 0;" 
"    if (d<=FogMin) return 1;" 
"" 
"    return (FogMax - d) / (FogMax - FogMin);" 
"}" 
"" 
"void drawSegment(vec2 points[4], vec4 colors[4], float zValues[4])" 
"{" 
"    vec2 p0 = points[0];" 
"    vec2 p1 = points[1];" 
"    vec2 p2 = points[2];" 
"    vec2 p3 = points[3];" 
"" 
"    /* perform naive culling */" 
"    vec2 area = Viewport * 4;" 
"    if( p1.x < -area.x || p1.x > area.x ) return;" 
"    if( p1.y < -area.y || p1.y > area.y ) return;" 
"    if( p2.x < -area.x || p2.x > area.x ) return;" 
"    if( p2.y < -area.y || p2.y > area.y ) return;" 
"" 
"    /* determine the direction of each of the 3 segments (previous, current, next) */" 
"    vec2 v0 = normalize( p1 - p0 );" 
"    vec2 v1 = normalize( p2 - p1 );" 
"    vec2 v2 = normalize( p3 - p2 );" 
"" 
"    /* determine the normal of each of the 3 segments (previous, current, next) */" 
"    vec2 n0 = vec2( -v0.y, v0.x );" 
"    vec2 n1 = vec2( -v1.y, v1.x );" 
"    vec2 n2 = vec2( -v2.y, v2.x );" 
"" 
"    /* determine miter lines by averaging the normals of the 2 segments */" 
"    vec2 miter_a = normalize( n0 + n1 );	// miter at start of current segment" 
"    vec2 miter_b = normalize( n1 + n2 ); // miter at end of current segment" 
"" 
"    /* determine the length of the miter by projecting it onto normal and then inverse it */" 
"    float an1 = dot(miter_a, n1);" 
"    float bn1 = dot(miter_b, n2);" 
"    if (an1==0) an1 = 1;" 
"    if (bn1==0) bn1 = 1;" 
"    float length_a = Thickness / an1;" 
"    float length_b = Thickness / bn1;" 
"" 
"    /* prevent excessively long miters at sharp corners */" 
"    if( dot( v0, v1 ) < -MiterLimit ) {" 
"        miter_a = n1;" 
"        length_a = Thickness;" 
"" 
"        /* close the gap */" 
"        if( dot( v0, n1 ) > 0 ) {" 
"            VertexOut.mTexCoord = vec2( 0, 0 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 + Thickness * n0 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 + Thickness * n1 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0.5 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( p1 / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            EndPrimitive();" 
"        }" 
"        else {" 
"            VertexOut.mTexCoord = vec2( 0, 1 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 - Thickness * n1 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 1 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 - Thickness * n0 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0.5 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( p1 / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            EndPrimitive();" 
"        }" 
"    }" 
"    if( dot( v1, v2 ) < -MiterLimit ) {" 
"        miter_b = n1;" 
"        length_b = Thickness;" 
"    }" 
"    // generate the triangle strip" 
"    VertexOut.mTexCoord = vec2( 0, 0 );" 
"    VertexOut.mColor = colors[1];" 
"    gl_Position = vec4( ( p1 + length_a * miter_a ) / Viewport, zValues[1], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 1 );" 
"    VertexOut.mColor = colors[1];" 
"    gl_Position = vec4( ( p1 - length_a * miter_a ) / Viewport, zValues[1], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 0 );" 
"    VertexOut.mColor = colors[2];" 
"    gl_Position = vec4( ( p2 + length_b * miter_b ) / Viewport, zValues[2], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 1 );" 
"    VertexOut.mColor = colors[2];" 
"    gl_Position = vec4( ( p2 - length_b * miter_b ) / Viewport, zValues[2], 1.0 );" 
"    EmitVertex();" 
"" 
"    EndPrimitive();" 
"}" 
"" 
"void main(void)" 
"{" 
"    /* cut segments number if larger than allowed */" 
"    int nSegments = (Segments > SegmentsMax)? SegmentsMax : Segments;" 
"    nSegments = (nSegments < SegmentsMin)? SegmentsMin: nSegments;" 
"" 
"    /* read the input */" 
"    vec4 B[4], V[4], C[4];" 
"    for (int i=0; i<4; ++i){" 
"        B[i] = gl_in[i].gl_Position; // bezier points" 
"        V[i] = VertexIn[i].mVertex; // vertex format" 
"        C[i] = VertexIn[i].mColor; // attached colors" 
"    }" 
"" 
"    /* adjust alpha channels wrt camera eye distance */" 
"    if (IsFogged){" 
"        for (int i=0; i<4; ++i){" 
"            float d = distance(CameraEye, V[0]);" 
"            float alpha = getFogFactor(d);" 
"            C[i] = vec4(C[i].rgb, alpha);" 
"        }" 
"    }" 
"" 
"    /* get the 2d bezier control points */" 
"    vec2 b0 = toScreenSpace( B[0] );" 
"    vec2 b1 = toScreenSpace( B[1] );" 
"    vec2 b2 = toScreenSpace( B[2] );" 
"    vec2 b3 = toScreenSpace( B[3] );" 
"" 
"    /* use the points to build a bezier line */" 
"    float delta = 1.0 / float(nSegments);" 
"    vec4 P[4]; // interpolated 3D points of Bezier" 
"    vec2 points[4]; // interpolated 2D points of Bezier" 
"    vec4 colors[4]; // interpolated colors" 
"    float zValues[4]; // stroke z-values" 
"     int j = 0; // bezier segment index for color interpolation" 
"    for (int i=0; i<=nSegments; ++i){" 
"        /* first point */" 
"        if (i==0){" 
"            P[1] = toBezier3D(delta, i, B[0], B[1], B[2], B[3]);" 
"            P[2] = toBezier3D(delta, i+1, B[0], B[1], B[2], B[3]);" 
"            P[3] = toBezier3D(delta, i+2, B[0], B[1], B[2], B[3]);" 
"            vec4 D = normalize(P[2] - P[1]);" 
"            P[0] = P[1] + D * 0.01;" 
"        }" 
"        else if (i < nSegments-1){" 
"            P[0] = P[1];" 
"            P[1] = P[2];" 
"            P[2] = P[3];" 
"            P[3] = toBezier3D(delta, i+2, B[0], B[1], B[2], B[3]);" 
"        }" 
"        /* last point */" 
"        else {" 
"            P[0] = P[1];" 
"            P[1] = P[2];" 
"            P[2] = P[3];" 
"            vec4 D = normalize(P[2] - P[1]);" 
"            P[3] = P[2] + D * 0.01;" 
"        }" 
"" 
"        {" 
"            if (i==0) colors[1] = C[0];" 
"            else colors[1] = colors[2];" 
"" 
"            /* fraction p{i} is located between fraction p{j} and p{j+1} */" 
"            float pi = float(i+1) / float(nSegments);" 
"            if (pi >= float(j+1)/3.f) j++;" 
"            float pj = float(j)/3.f; // 4 bezier points means 3 segments between which points are plotted" 
"            float pj1 = float(j+1)/3.f;" 
"            float a = (pi-pj) / (pj1-pj);" 
"            colors[2] = mix(C[j], C[j+1], a); // j <= 3" 
"        }" 
"" 
"        /* stroke z-values */" 
"        points[0] = toScreenSpace(P[0]);" 
"        points[1] = toScreenSpace(P[1]);" 
"        points[2] = toScreenSpace(P[2]);" 
"        points[3] = toScreenSpace(P[3]);" 
"" 
"        zValues[0] = toZValue(P[0]);" 
"        zValues[1] = toZValue(P[1]);" 
"        zValues[2] = toZValue(P[2]);" 
"        zValues[3] = toZValue(P[3]);" 
"" 
"        drawSegment(points, colors, zValues);" 
"    }" 
"" 
"}" 
}
}
                                    osg::Shader {
                                      UniqueID 13 
                                      Type FRAGMENT 
ShaderSource 11 {
"#version 330" 
"" 
"in VertexData{" 
"    vec2 mTexCoord;" 
"    vec4 mColor;" 
"} VertexIn;" 
"" 
"void main(void)" 
"{" 
"    gl_FragColor = VertexIn.mColor;" 
"}" 
}
}
                                  }
GeometryVerticesOut GL_GEOMETRY_VERTICES_OUT_EXT 1 
GeometryInputType GL_GEOMETRY_INPUT_TYPE_EXT 4 
GeometryOutputType GL_GEOMETRY_OUTPUT_TYPE_EXT 5 
FeedBackVaryingsName 0 {
}
FeedBackMode 35981 
}
                                Value OFF 
}
UniformList 10 {
osg::Uniform {
                                  UniqueID 14 
                                  Name "CameraEye" 
Type FLOAT_VEC4 
NumElements 1 
Elements TRUE ArrayID 1 FloatArray 4 {
                                    0 3.8637 1.71583e-015 1 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 15 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 16 
                                  Name "CanvasMatrix" 
Type FLOAT_MAT4 
NumElements 1 
Elements TRUE ArrayID 2 FloatArray 16 {
                                    1 0 0 0 
                                    0 1 0 0 
                                    0 0 1 0 
                                    0 0.6 0 1 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 17 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 18 
                                  Name "FogMax" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 3 FloatArray 1 {
                                    30 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 19 
                                  Name "FogMin" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 4 FloatArray 1 {
                                    4 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 20 
                                  Name "IsFogged" 
Type BOOL 
NumElements 1 
Elements TRUE ArrayID 5 IntArray 1 {
                                    0 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 21 
                                  Name "MiterLimit" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 6 FloatArray 1 {
                                    0.75 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 22 
                                  Name "ModelViewProjectionMatrix" 
Type FLOAT_MAT4 
NumElements 1 
Elements TRUE ArrayID 7 FloatArray 16 {
                                    -2.32529 0 0 0 
                                    0 -1.65736e-015 -3.0825 -1 
                                    0 3.73205 -1.3689e-015 -4.44089e-016 
                                    0 -9.94418e-016 1.00362 3.2637 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 23 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 24 
                                  Name "Segments" 
Type INT 
NumElements 1 
Elements TRUE ArrayID 8 IntArray 1 {
                                    11 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 25 
                                  Name "Thickness" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 9 FloatArray 1 {
                                    4 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 26 
                                  Name "Viewport" 
Type FLOAT_VEC2 
NumElements 1 
Elements TRUE ArrayID 10 FloatArray 2 {
                                    2836 1767 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 27 
                                    }
                                  }
}
                                Value OFF 
}
}
                          }
}
                        osg::Geode {
                          UniqueID 28 
                        }
                      }
}
                  }
ValueList 1 {
TRUE 
}
}
              }
Matrix {
                1 0 0 0 
                0 1 0 0 
                0 0 1 0 
                0 0.6 0 1 
              }
              
}
          }
MatrixTranslation {
            1 0 0 0 
            0 1 0 0 
            0 0 1 0 
            0 0.6 0 1 
          }
          
Transform TRUE {
osg::MatrixTransform {
              UniqueID 5 
            }
          }
Switch TRUE {
osg::Switch {
              UniqueID 6 
            }
          }
GroupData TRUE {
osg::Group {
              UniqueID 7 
            }
          }
GeodeStrokes TRUE {
osg::Geode {
              UniqueID 8 
            }
          }
GeodePhotos TRUE {
osg::Geode {
              UniqueID 28 
            }
          }
Center 0 0.6 0 
Normal 0 0 1 
}
        entity::Canvas {
          UniqueID 29 
          Name "Canvas1" 
Children 1 {
osg::MatrixTransform {
              UniqueID 30 
              Name "Transform" 
Children 1 {
osg::Switch {
                  UniqueID 31 
                  Name "Switch" 
Children 1 {
osg::Group {
                      UniqueID 32 
                      NodeMask 0x10 
Children 2 {
osg::Geode {
                          UniqueID 33 
                          StateSet TRUE {
osg::StateSet {
                              UniqueID 34 
                              AttributeList 1 {
osg::Program {
                                  UniqueID 35 
                                  Name "ProgramStroke" 
Shaders 3 {
osg::Shader {
                                      UniqueID 36 
                                      Type VERTEX 
ShaderSource 19 {
"#version 330" 
"" 
"uniform mat4 ModelViewProjectionMatrix;" 
"uniform mat4 CanvasMatrix;" 
"" 
"layout(location = 0) in vec4 Vertex;" 
"layout(location = 1) in vec4 Color;" 
"" 
"out VertexData{" 
"    vec4 mColor;" 
"    vec4 mVertex; // to calculate distance to camera eye" 
"} VertexOut;" 
"" 
"void main(void)" 
"{" 
"    VertexOut.mColor = Color;" 
"    VertexOut.mVertex = CanvasMatrix * Vertex;" 
"    gl_Position = ModelViewProjectionMatrix * Vertex;" 
"}" 
}
}
                                    osg::Shader {
                                      UniqueID 37 
                                      Type GEOMETRY 
ShaderSource 258 {
"#version 330" 
"" 
"uniform float Thickness;" 
"uniform vec2 Viewport;" 
"uniform float MiterLimit;" 
"uniform int Segments;" 
"uniform bool IsFogged;" 
"uniform float FogMin;" 
"uniform float FogMax;" 
"uniform vec4 CameraEye;" 
"" 
"const int SegmentsMax = 30; // max_vertices = (SegmentsMax+1)*4;" 
"const int SegmentsMin = 3; // min number of segments per curve" 
"" 
"layout(lines_adjacency) in;" 
"layout(triangle_strip, max_vertices = 124) out;" 
"" 
"in VertexData{" 
"    vec4 mColor;" 
"    vec4 mVertex;" 
"} VertexIn[4];" 
"" 
"out VertexData{" 
"    vec2 mTexCoord; // fix before usage" 
"    vec4 mColor;" 
"} VertexOut;" 
"" 
"vec2 toScreenSpace(vec4 vertex)" 
"{" 
"    return vec2( vertex.xy / vertex.w ) * Viewport;" 
"}" 
"" 
"float toZValue(vec4 vertex)" 
"{" 
"    return vertex.z / vertex.w;" 
"}" 
"" 
"vec2 toBezier(float delta, int i, vec2 b0, vec2 b1, vec2 b2, vec2 b3)" 
"{" 
"    float t = delta * float(i);" 
"    float t2 = t * t;" 
"    float one_minus_t = 1.0 - t;" 
"    float one_minus_t2 = one_minus_t * one_minus_t;" 
"    return (b0 * one_minus_t2 * one_minus_t + b1 * 3.0 * t * one_minus_t2 + b2 * 3.0 * t2 * one_minus_t + b3 * t2 * t);" 
"}" 
"" 
"vec4 toBezier3D(float delta, int i, vec4 B0, vec4 B1, vec4 B2, vec4 B3)" 
"{" 
"    float t = delta * float(i);" 
"    float t2 = t * t;" 
"    float one_minus_t = 1.0 - t;" 
"    float one_minus_t2 = one_minus_t * one_minus_t;" 
"    return (B0 * one_minus_t2 * one_minus_t + B1 * 3.0 * t * one_minus_t2 + B2 * 3.0 * t2 * one_minus_t + B3 * t2 * t);" 
"}" 
"" 
"float getFogFactor(float d)" 
"{" 
"    if (d>=FogMax) return 0;" 
"    if (d<=FogMin) return 1;" 
"" 
"    return (FogMax - d) / (FogMax - FogMin);" 
"}" 
"" 
"void drawSegment(vec2 points[4], vec4 colors[4], float zValues[4])" 
"{" 
"    vec2 p0 = points[0];" 
"    vec2 p1 = points[1];" 
"    vec2 p2 = points[2];" 
"    vec2 p3 = points[3];" 
"" 
"    /* perform naive culling */" 
"    vec2 area = Viewport * 4;" 
"    if( p1.x < -area.x || p1.x > area.x ) return;" 
"    if( p1.y < -area.y || p1.y > area.y ) return;" 
"    if( p2.x < -area.x || p2.x > area.x ) return;" 
"    if( p2.y < -area.y || p2.y > area.y ) return;" 
"" 
"    /* determine the direction of each of the 3 segments (previous, current, next) */" 
"    vec2 v0 = normalize( p1 - p0 );" 
"    vec2 v1 = normalize( p2 - p1 );" 
"    vec2 v2 = normalize( p3 - p2 );" 
"" 
"    /* determine the normal of each of the 3 segments (previous, current, next) */" 
"    vec2 n0 = vec2( -v0.y, v0.x );" 
"    vec2 n1 = vec2( -v1.y, v1.x );" 
"    vec2 n2 = vec2( -v2.y, v2.x );" 
"" 
"    /* determine miter lines by averaging the normals of the 2 segments */" 
"    vec2 miter_a = normalize( n0 + n1 );	// miter at start of current segment" 
"    vec2 miter_b = normalize( n1 + n2 ); // miter at end of current segment" 
"" 
"    /* determine the length of the miter by projecting it onto normal and then inverse it */" 
"    float an1 = dot(miter_a, n1);" 
"    float bn1 = dot(miter_b, n2);" 
"    if (an1==0) an1 = 1;" 
"    if (bn1==0) bn1 = 1;" 
"    float length_a = Thickness / an1;" 
"    float length_b = Thickness / bn1;" 
"" 
"    /* prevent excessively long miters at sharp corners */" 
"    if( dot( v0, v1 ) < -MiterLimit ) {" 
"        miter_a = n1;" 
"        length_a = Thickness;" 
"" 
"        /* close the gap */" 
"        if( dot( v0, n1 ) > 0 ) {" 
"            VertexOut.mTexCoord = vec2( 0, 0 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 + Thickness * n0 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 + Thickness * n1 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0.5 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( p1 / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            EndPrimitive();" 
"        }" 
"        else {" 
"            VertexOut.mTexCoord = vec2( 0, 1 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 - Thickness * n1 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 1 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 - Thickness * n0 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0.5 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( p1 / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            EndPrimitive();" 
"        }" 
"    }" 
"    if( dot( v1, v2 ) < -MiterLimit ) {" 
"        miter_b = n1;" 
"        length_b = Thickness;" 
"    }" 
"    // generate the triangle strip" 
"    VertexOut.mTexCoord = vec2( 0, 0 );" 
"    VertexOut.mColor = colors[1];" 
"    gl_Position = vec4( ( p1 + length_a * miter_a ) / Viewport, zValues[1], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 1 );" 
"    VertexOut.mColor = colors[1];" 
"    gl_Position = vec4( ( p1 - length_a * miter_a ) / Viewport, zValues[1], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 0 );" 
"    VertexOut.mColor = colors[2];" 
"    gl_Position = vec4( ( p2 + length_b * miter_b ) / Viewport, zValues[2], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 1 );" 
"    VertexOut.mColor = colors[2];" 
"    gl_Position = vec4( ( p2 - length_b * miter_b ) / Viewport, zValues[2], 1.0 );" 
"    EmitVertex();" 
"" 
"    EndPrimitive();" 
"}" 
"" 
"void main(void)" 
"{" 
"    /* cut segments number if larger than allowed */" 
"    int nSegments = (Segments > SegmentsMax)? SegmentsMax : Segments;" 
"    nSegments = (nSegments < SegmentsMin)? SegmentsMin: nSegments;" 
"" 
"    /* read the input */" 
"    vec4 B[4], V[4], C[4];" 
"    for (int i=0; i<4; ++i){" 
"        B[i] = gl_in[i].gl_Position; // bezier points" 
"        V[i] = VertexIn[i].mVertex; // vertex format" 
"        C[i] = VertexIn[i].mColor; // attached colors" 
"    }" 
"" 
"    /* adjust alpha channels wrt camera eye distance */" 
"    if (IsFogged){" 
"        for (int i=0; i<4; ++i){" 
"            float d = distance(CameraEye, V[0]);" 
"            float alpha = getFogFactor(d);" 
"            C[i] = vec4(C[i].rgb, alpha);" 
"        }" 
"    }" 
"" 
"    /* get the 2d bezier control points */" 
"    vec2 b0 = toScreenSpace( B[0] );" 
"    vec2 b1 = toScreenSpace( B[1] );" 
"    vec2 b2 = toScreenSpace( B[2] );" 
"    vec2 b3 = toScreenSpace( B[3] );" 
"" 
"    /* use the points to build a bezier line */" 
"    float delta = 1.0 / float(nSegments);" 
"    vec4 P[4]; // interpolated 3D points of Bezier" 
"    vec2 points[4]; // interpolated 2D points of Bezier" 
"    vec4 colors[4]; // interpolated colors" 
"    float zValues[4]; // stroke z-values" 
"     int j = 0; // bezier segment index for color interpolation" 
"    for (int i=0; i<=nSegments; ++i){" 
"        /* first point */" 
"        if (i==0){" 
"            P[1] = toBezier3D(delta, i, B[0], B[1], B[2], B[3]);" 
"            P[2] = toBezier3D(delta, i+1, B[0], B[1], B[2], B[3]);" 
"            P[3] = toBezier3D(delta, i+2, B[0], B[1], B[2], B[3]);" 
"            vec4 D = normalize(P[2] - P[1]);" 
"            P[0] = P[1] + D * 0.01;" 
"        }" 
"        else if (i < nSegments-1){" 
"            P[0] = P[1];" 
"            P[1] = P[2];" 
"            P[2] = P[3];" 
"            P[3] = toBezier3D(delta, i+2, B[0], B[1], B[2], B[3]);" 
"        }" 
"        /* last point */" 
"        else {" 
"            P[0] = P[1];" 
"            P[1] = P[2];" 
"            P[2] = P[3];" 
"            vec4 D = normalize(P[2] - P[1]);" 
"            P[3] = P[2] + D * 0.01;" 
"        }" 
"" 
"        {" 
"            if (i==0) colors[1] = C[0];" 
"            else colors[1] = colors[2];" 
"" 
"            /* fraction p{i} is located between fraction p{j} and p{j+1} */" 
"            float pi = float(i+1) / float(nSegments);" 
"            if (pi >= float(j+1)/3.f) j++;" 
"            float pj = float(j)/3.f; // 4 bezier points means 3 segments between which points are plotted" 
"            float pj1 = float(j+1)/3.f;" 
"            float a = (pi-pj) / (pj1-pj);" 
"            colors[2] = mix(C[j], C[j+1], a); // j <= 3" 
"        }" 
"" 
"        /* stroke z-values */" 
"        points[0] = toScreenSpace(P[0]);" 
"        points[1] = toScreenSpace(P[1]);" 
"        points[2] = toScreenSpace(P[2]);" 
"        points[3] = toScreenSpace(P[3]);" 
"" 
"        zValues[0] = toZValue(P[0]);" 
"        zValues[1] = toZValue(P[1]);" 
"        zValues[2] = toZValue(P[2]);" 
"        zValues[3] = toZValue(P[3]);" 
"" 
"        drawSegment(points, colors, zValues);" 
"    }" 
"" 
"}" 
}
}
                                    osg::Shader {
                                      UniqueID 38 
                                      Type FRAGMENT 
ShaderSource 11 {
"#version 330" 
"" 
"in VertexData{" 
"    vec2 mTexCoord;" 
"    vec4 mColor;" 
"} VertexIn;" 
"" 
"void main(void)" 
"{" 
"    gl_FragColor = VertexIn.mColor;" 
"}" 
}
}
                                  }
GeometryVerticesOut GL_GEOMETRY_VERTICES_OUT_EXT 1 
GeometryInputType GL_GEOMETRY_INPUT_TYPE_EXT 4 
GeometryOutputType GL_GEOMETRY_OUTPUT_TYPE_EXT 5 
FeedBackVaryingsName 0 {
}
FeedBackMode 35981 
}
                                Value OFF 
}
UniformList 10 {
osg::Uniform {
                                  UniqueID 39 
                                  Name "CameraEye" 
Type FLOAT_VEC4 
NumElements 1 
Elements TRUE ArrayID 11 FloatArray 4 {
                                    0 3.8637 1.71583e-015 1 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 40 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 41 
                                  Name "CanvasMatrix" 
Type FLOAT_MAT4 
NumElements 1 
Elements TRUE ArrayID 12 FloatArray 16 {
                                    -1.03473e-013 0 1 0 
                                    0 1 0 0 
                                    -1 0 -1.03473e-013 0 
                                    0 0.6 0 1 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 42 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 43 
                                  Name "FogMax" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 13 FloatArray 1 {
                                    30 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 44 
                                  Name "FogMin" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 14 FloatArray 1 {
                                    4 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 45 
                                  Name "IsFogged" 
Type BOOL 
NumElements 1 
Elements TRUE ArrayID 15 IntArray 1 {
                                    0 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 46 
                                  Name "MiterLimit" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 16 FloatArray 1 {
                                    0.75 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 47 
                                  Name "ModelViewProjectionMatrix" 
Type FLOAT_MAT4 
NumElements 1 
Elements TRUE ArrayID 17 FloatArray 16 {
                                    2.40605e-013 3.73205 -1.3689e-015 -4.44089e-016 
                                    0 -1.65736e-015 -3.0825 -1 
                                    2.32529 -3.86166e-013 1.41644e-028 4.59511e-029 
                                    0 -9.94418e-016 1.00362 3.2637 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 48 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 49 
                                  Name "Segments" 
Type INT 
NumElements 1 
Elements TRUE ArrayID 18 IntArray 1 {
                                    11 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 50 
                                  Name "Thickness" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 19 FloatArray 1 {
                                    4 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 51 
                                  Name "Viewport" 
Type FLOAT_VEC2 
NumElements 1 
Elements TRUE ArrayID 20 FloatArray 2 {
                                    2836 1767 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 52 
                                    }
                                  }
}
                                Value OFF 
}
}
                          }
}
                        osg::Geode {
                          UniqueID 53 
                        }
                      }
}
                  }
ValueList 1 {
TRUE 
}
}
              }
Matrix {
                -1.03473e-013 0 1 0 
                0 1 0 0 
                -1 0 -1.03473e-013 0 
                0 0.6 0 1 
              }
              
}
          }
MatrixRotation {
            -1.03473e-013 0 1 0 
            0 1 0 0 
            -1 0 -1.03473e-013 0 
            0 0 0 1 
          }
          
MatrixTranslation {
            1 0 0 0 
            0 1 0 0 
            0 0 1 0 
            0 0.6 0 1 
          }
          
Transform TRUE {
osg::MatrixTransform {
              UniqueID 30 
            }
          }
Switch TRUE {
osg::Switch {
              UniqueID 31 
            }
          }
GroupData TRUE {
osg::Group {
              UniqueID 32 
            }
          }
GeodeStrokes TRUE {
osg::Geode {
              UniqueID 33 
            }
          }
GeodePhotos TRUE {
osg::Geode {
              UniqueID 53 
            }
          }
Center 0 0.6 0 
Normal -1 0 -1.03473e-013 
}
        entity::Canvas {
          UniqueID 54 
          Name "Canvas2" 
Children 1 {
osg::MatrixTransform {
              UniqueID 55 
              Name "Transform" 
Children 1 {
osg::Switch {
                  UniqueID 56 
                  Name "Switch" 
Children 1 {
osg::Group {
                      UniqueID 57 
                      NodeMask 0x10 
Children 2 {
osg::Geode {
                          UniqueID 58 
                          StateSet TRUE {
osg::StateSet {
                              UniqueID 59 
                              AttributeList 1 {
osg::Program {
                                  UniqueID 60 
                                  Name "ProgramStroke" 
Shaders 3 {
osg::Shader {
                                      UniqueID 61 
                                      Type VERTEX 
ShaderSource 19 {
"#version 330" 
"" 
"uniform mat4 ModelViewProjectionMatrix;" 
"uniform mat4 CanvasMatrix;" 
"" 
"layout(location = 0) in vec4 Vertex;" 
"layout(location = 1) in vec4 Color;" 
"" 
"out VertexData{" 
"    vec4 mColor;" 
"    vec4 mVertex; // to calculate distance to camera eye" 
"} VertexOut;" 
"" 
"void main(void)" 
"{" 
"    VertexOut.mColor = Color;" 
"    VertexOut.mVertex = CanvasMatrix * Vertex;" 
"    gl_Position = ModelViewProjectionMatrix * Vertex;" 
"}" 
}
}
                                    osg::Shader {
                                      UniqueID 62 
                                      Type GEOMETRY 
ShaderSource 258 {
"#version 330" 
"" 
"uniform float Thickness;" 
"uniform vec2 Viewport;" 
"uniform float MiterLimit;" 
"uniform int Segments;" 
"uniform bool IsFogged;" 
"uniform float FogMin;" 
"uniform float FogMax;" 
"uniform vec4 CameraEye;" 
"" 
"const int SegmentsMax = 30; // max_vertices = (SegmentsMax+1)*4;" 
"const int SegmentsMin = 3; // min number of segments per curve" 
"" 
"layout(lines_adjacency) in;" 
"layout(triangle_strip, max_vertices = 124) out;" 
"" 
"in VertexData{" 
"    vec4 mColor;" 
"    vec4 mVertex;" 
"} VertexIn[4];" 
"" 
"out VertexData{" 
"    vec2 mTexCoord; // fix before usage" 
"    vec4 mColor;" 
"} VertexOut;" 
"" 
"vec2 toScreenSpace(vec4 vertex)" 
"{" 
"    return vec2( vertex.xy / vertex.w ) * Viewport;" 
"}" 
"" 
"float toZValue(vec4 vertex)" 
"{" 
"    return vertex.z / vertex.w;" 
"}" 
"" 
"vec2 toBezier(float delta, int i, vec2 b0, vec2 b1, vec2 b2, vec2 b3)" 
"{" 
"    float t = delta * float(i);" 
"    float t2 = t * t;" 
"    float one_minus_t = 1.0 - t;" 
"    float one_minus_t2 = one_minus_t * one_minus_t;" 
"    return (b0 * one_minus_t2 * one_minus_t + b1 * 3.0 * t * one_minus_t2 + b2 * 3.0 * t2 * one_minus_t + b3 * t2 * t);" 
"}" 
"" 
"vec4 toBezier3D(float delta, int i, vec4 B0, vec4 B1, vec4 B2, vec4 B3)" 
"{" 
"    float t = delta * float(i);" 
"    float t2 = t * t;" 
"    float one_minus_t = 1.0 - t;" 
"    float one_minus_t2 = one_minus_t * one_minus_t;" 
"    return (B0 * one_minus_t2 * one_minus_t + B1 * 3.0 * t * one_minus_t2 + B2 * 3.0 * t2 * one_minus_t + B3 * t2 * t);" 
"}" 
"" 
"float getFogFactor(float d)" 
"{" 
"    if (d>=FogMax) return 0;" 
"    if (d<=FogMin) return 1;" 
"" 
"    return (FogMax - d) / (FogMax - FogMin);" 
"}" 
"" 
"void drawSegment(vec2 points[4], vec4 colors[4], float zValues[4])" 
"{" 
"    vec2 p0 = points[0];" 
"    vec2 p1 = points[1];" 
"    vec2 p2 = points[2];" 
"    vec2 p3 = points[3];" 
"" 
"    /* perform naive culling */" 
"    vec2 area = Viewport * 4;" 
"    if( p1.x < -area.x || p1.x > area.x ) return;" 
"    if( p1.y < -area.y || p1.y > area.y ) return;" 
"    if( p2.x < -area.x || p2.x > area.x ) return;" 
"    if( p2.y < -area.y || p2.y > area.y ) return;" 
"" 
"    /* determine the direction of each of the 3 segments (previous, current, next) */" 
"    vec2 v0 = normalize( p1 - p0 );" 
"    vec2 v1 = normalize( p2 - p1 );" 
"    vec2 v2 = normalize( p3 - p2 );" 
"" 
"    /* determine the normal of each of the 3 segments (previous, current, next) */" 
"    vec2 n0 = vec2( -v0.y, v0.x );" 
"    vec2 n1 = vec2( -v1.y, v1.x );" 
"    vec2 n2 = vec2( -v2.y, v2.x );" 
"" 
"    /* determine miter lines by averaging the normals of the 2 segments */" 
"    vec2 miter_a = normalize( n0 + n1 );	// miter at start of current segment" 
"    vec2 miter_b = normalize( n1 + n2 ); // miter at end of current segment" 
"" 
"    /* determine the length of the miter by projecting it onto normal and then inverse it */" 
"    float an1 = dot(miter_a, n1);" 
"    float bn1 = dot(miter_b, n2);" 
"    if (an1==0) an1 = 1;" 
"    if (bn1==0) bn1 = 1;" 
"    float length_a = Thickness / an1;" 
"    float length_b = Thickness / bn1;" 
"" 
"    /* prevent excessively long miters at sharp corners */" 
"    if( dot( v0, v1 ) < -MiterLimit ) {" 
"        miter_a = n1;" 
"        length_a = Thickness;" 
"" 
"        /* close the gap */" 
"        if( dot( v0, n1 ) > 0 ) {" 
"            VertexOut.mTexCoord = vec2( 0, 0 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 + Thickness * n0 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 + Thickness * n1 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0.5 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( p1 / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            EndPrimitive();" 
"        }" 
"        else {" 
"            VertexOut.mTexCoord = vec2( 0, 1 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 - Thickness * n1 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 1 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( ( p1 - Thickness * n0 ) / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            VertexOut.mTexCoord = vec2( 0, 0.5 );" 
"            VertexOut.mColor = colors[1];" 
"            gl_Position = vec4( p1 / Viewport, zValues[1], 1.0 );" 
"            EmitVertex();" 
"" 
"            EndPrimitive();" 
"        }" 
"    }" 
"    if( dot( v1, v2 ) < -MiterLimit ) {" 
"        miter_b = n1;" 
"        length_b = Thickness;" 
"    }" 
"    // generate the triangle strip" 
"    VertexOut.mTexCoord = vec2( 0, 0 );" 
"    VertexOut.mColor = colors[1];" 
"    gl_Position = vec4( ( p1 + length_a * miter_a ) / Viewport, zValues[1], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 1 );" 
"    VertexOut.mColor = colors[1];" 
"    gl_Position = vec4( ( p1 - length_a * miter_a ) / Viewport, zValues[1], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 0 );" 
"    VertexOut.mColor = colors[2];" 
"    gl_Position = vec4( ( p2 + length_b * miter_b ) / Viewport, zValues[2], 1.0 );" 
"    EmitVertex();" 
"" 
"    VertexOut.mTexCoord = vec2( 0, 1 );" 
"    VertexOut.mColor = colors[2];" 
"    gl_Position = vec4( ( p2 - length_b * miter_b ) / Viewport, zValues[2], 1.0 );" 
"    EmitVertex();" 
"" 
"    EndPrimitive();" 
"}" 
"" 
"void main(void)" 
"{" 
"    /* cut segments number if larger than allowed */" 
"    int nSegments = (Segments > SegmentsMax)? SegmentsMax : Segments;" 
"    nSegments = (nSegments < SegmentsMin)? SegmentsMin: nSegments;" 
"" 
"    /* read the input */" 
"    vec4 B[4], V[4], C[4];" 
"    for (int i=0; i<4; ++i){" 
"        B[i] = gl_in[i].gl_Position; // bezier points" 
"        V[i] = VertexIn[i].mVertex; // vertex format" 
"        C[i] = VertexIn[i].mColor; // attached colors" 
"    }" 
"" 
"    /* adjust alpha channels wrt camera eye distance */" 
"    if (IsFogged){" 
"        for (int i=0; i<4; ++i){" 
"            float d = distance(CameraEye, V[0]);" 
"            float alpha = getFogFactor(d);" 
"            C[i] = vec4(C[i].rgb, alpha);" 
"        }" 
"    }" 
"" 
"    /* get the 2d bezier control points */" 
"    vec2 b0 = toScreenSpace( B[0] );" 
"    vec2 b1 = toScreenSpace( B[1] );" 
"    vec2 b2 = toScreenSpace( B[2] );" 
"    vec2 b3 = toScreenSpace( B[3] );" 
"" 
"    /* use the points to build a bezier line */" 
"    float delta = 1.0 / float(nSegments);" 
"    vec4 P[4]; // interpolated 3D points of Bezier" 
"    vec2 points[4]; // interpolated 2D points of Bezier" 
"    vec4 colors[4]; // interpolated colors" 
"    float zValues[4]; // stroke z-values" 
"     int j = 0; // bezier segment index for color interpolation" 
"    for (int i=0; i<=nSegments; ++i){" 
"        /* first point */" 
"        if (i==0){" 
"            P[1] = toBezier3D(delta, i, B[0], B[1], B[2], B[3]);" 
"            P[2] = toBezier3D(delta, i+1, B[0], B[1], B[2], B[3]);" 
"            P[3] = toBezier3D(delta, i+2, B[0], B[1], B[2], B[3]);" 
"            vec4 D = normalize(P[2] - P[1]);" 
"            P[0] = P[1] + D * 0.01;" 
"        }" 
"        else if (i < nSegments-1){" 
"            P[0] = P[1];" 
"            P[1] = P[2];" 
"            P[2] = P[3];" 
"            P[3] = toBezier3D(delta, i+2, B[0], B[1], B[2], B[3]);" 
"        }" 
"        /* last point */" 
"        else {" 
"            P[0] = P[1];" 
"            P[1] = P[2];" 
"            P[2] = P[3];" 
"            vec4 D = normalize(P[2] - P[1]);" 
"            P[3] = P[2] + D * 0.01;" 
"        }" 
"" 
"        {" 
"            if (i==0) colors[1] = C[0];" 
"            else colors[1] = colors[2];" 
"" 
"            /* fraction p{i} is located between fraction p{j} and p{j+1} */" 
"            float pi = float(i+1) / float(nSegments);" 
"            if (pi >= float(j+1)/3.f) j++;" 
"            float pj = float(j)/3.f; // 4 bezier points means 3 segments between which points are plotted" 
"            float pj1 = float(j+1)/3.f;" 
"            float a = (pi-pj) / (pj1-pj);" 
"            colors[2] = mix(C[j], C[j+1], a); // j <= 3" 
"        }" 
"" 
"        /* stroke z-values */" 
"        points[0] = toScreenSpace(P[0]);" 
"        points[1] = toScreenSpace(P[1]);" 
"        points[2] = toScreenSpace(P[2]);" 
"        points[3] = toScreenSpace(P[3]);" 
"" 
"        zValues[0] = toZValue(P[0]);" 
"        zValues[1] = toZValue(P[1]);" 
"        zValues[2] = toZValue(P[2]);" 
"        zValues[3] = toZValue(P[3]);" 
"" 
"        drawSegment(points, colors, zValues);" 
"    }" 
"" 
"}" 
}
}
                                    osg::Shader {
                                      UniqueID 63 
                                      Type FRAGMENT 
ShaderSource 11 {
"#version 330" 
"" 
"in VertexData{" 
"    vec2 mTexCoord;" 
"    vec4 mColor;" 
"} VertexIn;" 
"" 
"void main(void)" 
"{" 
"    gl_FragColor = VertexIn.mColor;" 
"}" 
}
}
                                  }
GeometryVerticesOut GL_GEOMETRY_VERTICES_OUT_EXT 1 
GeometryInputType GL_GEOMETRY_INPUT_TYPE_EXT 4 
GeometryOutputType GL_GEOMETRY_OUTPUT_TYPE_EXT 5 
FeedBackVaryingsName 0 {
}
FeedBackMode 35981 
}
                                Value OFF 
}
UniformList 10 {
osg::Uniform {
                                  UniqueID 64 
                                  Name "CameraEye" 
Type FLOAT_VEC4 
NumElements 1 
Elements TRUE ArrayID 21 FloatArray 4 {
                                    0 3.8637 1.71583e-015 1 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 65 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 66 
                                  Name "CanvasMatrix" 
Type FLOAT_MAT4 
NumElements 1 
Elements TRUE ArrayID 22 FloatArray 16 {
                                    1 0 0 0 
                                    0 -1.03473e-013 1 0 
                                    0 -1 -1.03473e-013 0 
                                    0 0 0 1 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 67 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 68 
                                  Name "FogMax" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 23 FloatArray 1 {
                                    30 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 69 
                                  Name "FogMin" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 24 FloatArray 1 {
                                    4 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 70 
                                  Name "IsFogged" 
Type BOOL 
NumElements 1 
Elements TRUE ArrayID 25 IntArray 1 {
                                    0 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 71 
                                  Name "MiterLimit" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 26 FloatArray 1 {
                                    0.75 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 72 
                                  Name "ModelViewProjectionMatrix" 
Type FLOAT_MAT4 
NumElements 1 
Elements TRUE ArrayID 27 FloatArray 16 {
                                    -2.32529 0 0 0 
                                    0 3.73205 3.17586e-013 1.03029e-013 
                                    0 -3.84508e-013 3.0825 1 
                                    0 0 2.85312 3.8637 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 73 
                                    }
                                  }
}
                                Value OFF 
osg::Uniform {
                                  UniqueID 74 
                                  Name "Segments" 
Type INT 
NumElements 1 
Elements TRUE ArrayID 28 IntArray 1 {
                                    11 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 75 
                                  Name "Thickness" 
Type FLOAT 
NumElements 1 
Elements TRUE ArrayID 29 FloatArray 1 {
                                    4 
                                  }
                                }
                                Value OFF 
osg::Uniform {
                                  UniqueID 76 
                                  Name "Viewport" 
Type FLOAT_VEC2 
NumElements 1 
Elements TRUE ArrayID 30 FloatArray 2 {
                                    2836 1767 
                                  }
                                  UpdateCallback TRUE {
osg::UniformCallback {
                                      UniqueID 77 
                                    }
                                  }
}
                                Value OFF 
}
}
                          }
Drawables 2 {
entity::Stroke {
                              UniqueID 78 
                              Name "Stroke" 
DataVariance DYNAMIC 
PrimitiveSetList 1 {
osg::DrawArrays {
                                  UniqueID 79 
                                  Mode LINES_ADJACENCY 
Count 16 
}
                              }
VertexArray TRUE {
osg::Vec3Array {
                                  UniqueID 80 
                                  Binding BIND_PER_VERTEX 
vector 16 {
0.608159 -0.272441 0 
0.631559 -0.237342 0 
0.498738 0.0721855 0 
0.481606 0.110734 0 
0.481606 0.110734 0 
0.449384 0.183233 0 
0.273632 0.227212 0 
0.257794 0.231428 0 
0.257794 0.231428 0 
0.022897 0.293966 0 
-0.24143 0.114673 0 
-0.481606 0.151747 0 
-0.481606 0.151747 0 
-0.61625 0.172531 0 
-0.814618 0.339233 0 
-0.953837 0.339233 0 
}
}
                              }
ColorArray TRUE {
osg::Vec4Array {
                                  UniqueID 81 
                                  Binding BIND_PER_VERTEX 
vector 16 {
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
}
}
                              }
VertexAttribArrayList 2 {
osg::Vec3Array {
                                  UniqueID 80 
                                }
                                osg::Vec4Array {
                                  UniqueID 81 
                                }
                              }
Lines TRUE {
osg::DrawArrays {
                                  UniqueID 79 
                                }
                              }
Color 0 0.168627 0.211765 1 
IsCurved TRUE 
}
                            entity::Stroke {
                              UniqueID 82 
                              Name "Stroke" 
DataVariance DYNAMIC 
PrimitiveSetList 1 {
osg::DrawArrays {
                                  UniqueID 83 
                                  Mode LINES_ADJACENCY 
Count 28 
}
                              }
VertexArray TRUE {
osg::Vec3Array {
                                  UniqueID 84 
                                  Binding BIND_PER_VERTEX 
vector 28 {
-0.434734 0.557186 0 
-0.434734 0.557186 0 
-0.489808 0.413056 0 
-0.489808 0.413056 0 
-0.489808 0.413056 0 
-0.511963 0.365636 0 
-0.627709 0.144224 0 
-0.646828 0.0955009 0 
-0.646828 0.0955009 0 
-0.649967 0.0875016 0 
-0.671155 0.0125708 0 
-0.672607 0.00410126 0 
-0.672607 0.00410126 0 
-0.672937 0.00217638 0 
-0.678366 -0.057225 0 
-0.678466 -0.0591754 0 
-0.678466 -0.0591754 0 
-0.678466 -0.0591754 0 
-0.678466 -0.109562 0 
-0.678466 -0.109562 0 
-0.678466 -0.109562 0 
-0.678466 -0.109562 0 
-0.650343 -0.19979 0 
-0.650343 -0.19979 0 
-0.650343 -0.19979 0 
-0.26186 -0.827976 0 
0.0902156 -0.720065 0 
0.476918 -0.720065 0 
}
}
                              }
ColorArray TRUE {
osg::Vec4Array {
                                  UniqueID 85 
                                  Binding BIND_PER_VERTEX 
vector 28 {
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
0 0.168627 0.211765 1 
}
}
                              }
VertexAttribArrayList 2 {
osg::Vec3Array {
                                  UniqueID 84 
                                }
                                osg::Vec4Array {
                                  UniqueID 85 
                                }
                              }
Lines TRUE {
osg::DrawArrays {
                                  UniqueID 83 
                                }
                              }
Color 0 0.168627 0.211765 1 
IsCurved TRUE 
}
                          }
}
                        osg::Geode {
                          UniqueID 86 
                        }
                      }
}
                  }
ValueList 1 {
TRUE 
}
}
              }
Matrix {
                1 0 0 0 
                0 -1.03473e-013 1 0 
                0 -1 -1.03473e-013 0 
                0 0 0 1 
              }
              
}
          }
MatrixRotation {
            1 0 0 0 
            0 -1.03473e-013 1 0 
            0 -1 -1.03473e-013 0 
            0 0 0 1 
          }
          
Transform TRUE {
osg::MatrixTransform {
              UniqueID 55 
            }
          }
Switch TRUE {
osg::Switch {
              UniqueID 56 
            }
          }
GroupData TRUE {
osg::Group {
              UniqueID 57 
            }
          }
GeodeStrokes TRUE {
osg::Geode {
              UniqueID 58 
            }
          }
GeodePhotos TRUE {
osg::Geode {
              UniqueID 86 
            }
          }
Normal 0 -1 -1.03473e-013 
}
      }
}
  }
GroupCanvases TRUE {
osg::Group {
      UniqueID 3 
    }
  }
Bookmarks TRUE {
entity::Bookmarks {
      UniqueID 2 
    }
  }
IdCanvas 3 
FilePath "C:/cygwin64/home/vr267/github/cherish/samples/test-local.osgt" 
}
